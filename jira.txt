// src/app/features/ai-search/ai-search.service.ts

logFeedback(entry: Partial<FeedbackEntry>): Observable<void> {
    const currentData = this.getStoredFeedbackSync();
    
    // 1. Check if we already have feedback for this specific Message ID
    const existingIndex = currentData.findIndex(e => e.id === entry.id);

    // CASE A: User removed feedback (clicked same button again) -> DELETE
    if (!entry.rating) {
        if (existingIndex > -1) {
            currentData.splice(existingIndex, 1);
            console.log('ðŸ—‘ï¸ Feedback removed for ID:', entry.id);
        }
    } 
    // CASE B: User added/changed feedback -> UPSERT
    else {
        const newRecord: FeedbackEntry = {
            id: entry.id!, // Assumes ID is always passed
            query: entry.query || 'Unknown Query',
            aiResponse: entry.aiResponse || '',
            user: entry.user || 'Anonymous',
            rating: entry.rating,
            timestamp: new Date().toISOString(),
            category: entry.category || 'General'
        };

        if (existingIndex > -1) {
            // Update existing
            currentData[existingIndex] = { ...currentData[existingIndex], ...newRecord };
            console.log('ðŸ”„ Feedback updated:', newRecord);
        } else {
            // Create new
            currentData.unshift(newRecord);
            console.log('âœ… New Feedback created:', newRecord);
        }
    }

    localStorage.setItem(FEEDBACK_STORAGE_KEY, JSON.stringify(currentData));
    return of(void 0);
}


---------------------

// src/app/features/ai-search/ai-search.component.ts

handleMessageFeedback(event: { index: number, type: 'like' | 'dislike' | null }) {
    // 1. Update Visuals
    this.chatMessages.update(msgs => {
      const newMsgs = [...msgs];
      newMsgs[event.index] = { ...newMsgs[event.index], feedback: event.type };
      return newMsgs;
    });

    // 2. Prepare Data
    const allMessages = this.chatMessages();
    const aiMsg = allMessages[event.index];
    
    // Find context (User Query)
    const previousMsg = allMessages[event.index - 1];
    const userQuery = (previousMsg && previousMsg.type === 'human') 
                      ? previousMsg.content 
                      : 'Unknown Context';

    // 3. ðŸš¨ FIX: Pass 'event.type' even if it is NULL (so service can delete)
    // Ensure we use a stable ID (aiMsg.id). If the message doesn't have an ID, 
    // generate one ONCE and save it to the message object so it persists.
    if (!aiMsg.id) {
        aiMsg.id = crypto.randomUUID(); 
    }

    this.aiService.logFeedback({
      id: aiMsg.id, 
      query: userQuery,
      aiResponse: aiMsg.content,
      rating: event.type, // Can be 'like', 'dislike', or null
      category: 'General',
      user: this.currentUser()?.name
    }).subscribe();
}
